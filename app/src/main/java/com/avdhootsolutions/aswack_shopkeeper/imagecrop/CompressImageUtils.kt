package com.avdhootsolutions.aswack_shopkeeper.imagecropimport com.avdhootsolutions.aswack_shopkeeper.imagecrop.CropParamsimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.net.Uriimport android.util.Logimport com.avdhootsolutions.aswack_shopkeeper.imagecrop.CompressImageUtilsimport java.io.Fileimport java.io.FileOutputStreamimport java.io.IOExceptionimport java.io.OutputStreamimport java.lang.Exceptionobject CompressImageUtils {    const val TAG = "ChoosePhotoUtils"    fun compressImageFile(cropParams: CropParams, originUri: Uri, compressUri: Uri) {        var bitmap: Bitmap? = null        var out: OutputStream? = null        try {            val options = BitmapFactory.Options()            options.inJustDecodeBounds = true            BitmapFactory.decodeFile(originUri.path, options)            // Calculate inSampleSize            val minSideLength =                if (cropParams.compressWidth > cropParams.compressHeight) cropParams.compressHeight else cropParams.compressWidth            options.inSampleSize = computeSampleSize(options,                minSideLength,                cropParams.compressWidth * cropParams.compressHeight)            // Decode bitmap with inSampleSize set            options.inJustDecodeBounds = false            bitmap = BitmapFactory.decodeFile(originUri.path, options)            val compressFile = File(compressUri.path)            if (!compressFile.exists()) {                val result = compressFile.createNewFile()                Log.d(TAG, "Target $compressUri not exist, create a new one $result")            }            out = FileOutputStream(compressFile)            val result =                bitmap.compress(Bitmap.CompressFormat.JPEG, cropParams.compressQuality, out)            Log.d(TAG, "Compress bitmap " + if (result) "succeed" else "failed")        } catch (e: Exception) {            Log.e(TAG, "compressInputStreamToOutputStream", e)        } finally {            bitmap?.recycle()            try {                out?.close()            } catch (ignore: IOException) {            }        }    }    fun computeSampleSize(        options: BitmapFactory.Options,        minSideLength: Int,        maxNumOfPixels: Int    ): Int {        val initialSize = computeInitialSampleSize(options, minSideLength, maxNumOfPixels)        var roundedSize: Int        if (initialSize <= 8) {            roundedSize = 1            while (roundedSize < initialSize) {                roundedSize = roundedSize shl 1            }        } else {            roundedSize = (initialSize + 7) / 8 * 8        }        return roundedSize    }    private fun computeInitialSampleSize(        options: BitmapFactory.Options,        minSideLength: Int,        maxNumOfPixels: Int    ): Int {        val w = options.outWidth.toDouble()        val h = options.outHeight.toDouble()        val lowerBound =            if (maxNumOfPixels == -1) 1 else Math.ceil(Math.sqrt(w * h / maxNumOfPixels))                .toInt()        val upperBound = if (minSideLength == -1) 128 else Math.min(Math.floor(w / minSideLength),            Math.floor(h / minSideLength)).toInt()        if (upperBound < lowerBound) {            // return the larger one when there is no overlapping zone.            return lowerBound        }        return if (maxNumOfPixels == -1 && minSideLength == -1) {            1        } else if (minSideLength == -1) {            lowerBound        } else {            upperBound        }    }}